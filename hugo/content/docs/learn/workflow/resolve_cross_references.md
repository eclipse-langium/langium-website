---
title: "5. Resolve cross-references"
weight: 600
url: /docs/learn/workflow/resolve_cross_references
---

This step takes place after generating the AST. The AST definition was created and you are able to parse input files. But the AST is not complete yet. It contains _cross-references_ that are not resolved. Cross-references are used to reference other elements in your language.

## Problem

Let's illustrate the problem using the Hello-World example from the Yeoman generator:

```text
person John
person Jane

Hello John!
Hello Jane!
```

The following syntax tree is generated by the Langium parser during the runtime. Mind the gaps with the question marks. These are the missing pieces you want to fill out in this step.

{{<mermaid>}}
graph TB
  Model-->persons
  Model-->greetings
  
  persons-->P1[Person]
  P1 --> H1('person')
  P1 --> N1[name]
  N1 --> NL1('John')
  
  persons-->P2[Person]
  P2 --> H2('person')
  P2 --> N2[name]
  N2 --> NL2('Jane')

  greetings-->G1[Greeting]
  G1 --> KW1('hello')
  G1 --> PRef1[Ref]
  PRef1 -- $refText --> RT1('John')
  G1 --> EM1('!')
  PRef1 --> QM1{?}

  greetings-->G2[Greeting]
  G2 --> KW2('hello')
  G2 --> PRef2[Ref]
  PRef2 -- $refText --> RT2('Jane')
  G2 --> EM2('!')
  PRef2 --> QM2{?}
{{</mermaid>}}

You normally can achieve the cross-reference resolution by implementing a so-called scope provider and a scope computation. When setup correctly given syntax tree will change to this:

{{<mermaid>}}
graph TB
  Model-->persons
  Model-->greetings
  
  persons-->P1[Person]
  P1 --> H1('person')
  P1 --> N1[name]
  N1 --> NL1('John')
  
  persons-->P2[Person]
  P2 --> H2('person')
  P2 --> N2[name]
  N2 --> NL2('Jane')

  greetings-->G1[Greeting]
  G1 --> KW1('hello')
  G1 --> PRef1[Ref]
  PRef1 -- $refText --> RT1('John')
  G1 --> EM1('!')
  PRef1 -..-> P1

  greetings-->G2[Greeting]
  G2 --> KW2('hello')
  G2 --> PRef2[Ref]
  PRef2 -- $refText --> RT2('Jane')
  G2 --> EM2('!')
  PRef2 -..-> P2
{{</mermaid>}}

## Resolution of cross-references

As already hinted, you can implement a scope provider and a scope computation. Fortunately, Langium comes with default implementations for both. But eventually as your language grows, you might want to implement your own strategy because the default is not sufficient. In the following sections the interpretation of the involved interfaces will be sketched.

### Scope provider

#### Terms

The _scope provider_ is responsible for providing a _scope_ for a given cross-reference represented by the `ReferenceInfo` type.

A _scope_ is a collection of AST nodes that are represented by the `AstNodeDescription` type.

The _description_ is like a (string) path through the AST of a document. It can be also seen as a tuple of document URI, JSON path, name and type of the AST node.

A _reference info_ contains the concrete AST reference (which points to nothing yet). The info also has the parent AST node (a so-called container) of the reference and the property name under which you can find the reference under its container. In the form of this tuple (`container`, `property`, `reference`) Langium visits all cross-references using the scope provider's `getScope` method.

```ts
export interface ScopeProvider {
    getScope(context: ReferenceInfo): Scope;
}

export interface ReferenceInfo {
    reference: Reference
    container: AstNode
    property: string
    index?: number
}

export interface Scope {
    getElement(name: string): AstNodeDescription | undefined;
    getAllElements(): Stream<AstNodeDescription>;
}
```

#### Purpose

So, what is the purpose of the scope provider? As mentioned above: it visits each cross-reference and tries to find the corresponding AST nodes over the entire workspace that can be a candidate for the cross-reference's place. It is important to understand that we do not decide here which of these nodes is the perfect match! That decision is part of the so-called linker of the Langium architecture.

Whether your cross-reference's `$refText` contains the name `Jane` does not matter here. We need to provide all nodes that are possible at this position. So in the result, you would return `Jane` and `John` AST nodes - for both cross-references!

The background for this behavior is that this mechanism can be used for two things: the cross-reference resolution and the code completion. The code completion needs to know all possible candidates for a given cross-reference. The resolution of the cross-reference is done by the linker: Given a scope for a certain cross-reference, the linker decides which of the candidates is the right one - for example the first candidate with the same name.

### Scope computation

The _scope computation_ is responsible for defining per document file...

1. which AST nodes are getting exported to the global scope. These nodes will be collected by the so-called _index manager_.
2. which AST nodes (as descriptions) are available in the local scope of a certain AST node. This is meant as a cache computation for the scope provider.

The _index manager_ is keeping in mind the global symbols of your language. It can be used by the scope provider to find the right candidates for a cross-reference.

```ts
export interface ScopeComputation {
  collectExportedSymbols(document: LangiumDocument, cancelToken?: CancellationToken): Promise<AstNodeDescription[]>;
  collectLocalSymbols(document: LangiumDocument, cancelToken?: CancellationToken): Promise<LocalSymbols>;
}
```

So, while the scope computation is defining what symbols are globally exported (like using the `export` keyword in Typescript), the scope provider is the place to implement the `import` of these symbols using the index manager and the semantics of your import logic.

## Cross-reference resolution from a high-level perspective

1. The AST gets generated by the parser for each document in the workspace.
2. The scope computation is called for each document in the workspace. All exported AST nodes are collected by the index manager.
3. The scope computation is called for each document in the workspace, again. All local scopes get computed and attached to the document.
4. The linker and the scope provider are called for each cross-reference in the workspace. The scope provider uses the index manager to find candidates for each cross-reference. The linker decides which candidate is the right one for each cross-reference.

## Example

For the Hello-World example, you can implement a scope provider and a scope computation like this (keep in mind that this is a alternative solution to the default implementation of Langium, which already works for most cases):

```ts
import { ReferenceInfo, Scope, ScopeProvider, AstUtils, LangiumCoreServices, AstNodeDescriptionProvider, MapScope, EMPTY_SCOPE } from "langium";
import { isGreeting, isModel } from "./generated/ast.js";

export class HelloWorldScopeProvider implements ScopeProvider {
    private astNodeDescriptionProvider: AstNodeDescriptionProvider;
    constructor(services: LangiumCoreServices) {
        //get some helper services
        this.astNodeDescriptionProvider = services.workspace.AstNodeDescriptionProvider;
    }
    getScope(context: ReferenceInfo): Scope {
        //make sure which cross-reference you are handling right now
        if(isGreeting(context.container) && context.property === 'person') {
            //Success! We are handling the cross-reference of a greeting to a person!

            //get the root node of the document
            const model = AstUtils.getContainerOfType(context.container, isModel)!;
            //select all persons from this document
            const persons = model.persons;
            //transform them into node descriptions
            const descriptions = persons.map(p => this.astNodeDescriptionProvider.createDescription(p, p.name));
            //create the scope
            return new MapScope(descriptions);
        }
        return EMPTY_SCOPE;
    }
}
```

Please make sure to override the default scope provider in your language module file like this:

```ts
//...
export const HelloWorldModule: Module<HelloWorldServices, PartialLangiumServices & HelloWorldAddedServices> = {
    //validation: ...
    references: {
        ScopeProvider: (services) => new HelloWorldScopeProvider(services)
    }
};
//...
```

## How to test the linking?

You can test the linking by comparing the resolved references with the expected references. Here is the example from the last step.

```ts
import { createHelloWorldServices } from "./your-project//hello-world-module.js";
import { EmptyFileSystem } from "langium";
import { parseHelper } from "langium/test";
import { Model } from "../../src/language/generated/ast.js";

//arrange
const services = createHelloWorldServices(EmptyFileSystem);
const parse = parseHelper<Model>(services.HelloWorld);

//act
const document = await parse(`
    person John
    person Jane
    
    Hello John!
    Hello Jane!
`);

//assert
const model = document.parseResult.value;
expect(model.persons).toHaveLength(2);
expect(model.greetings).toHaveLength(2);
expect(model.greetings[0].person.ref).toBe(model.persons[0]);
expect(model.greetings[1].person.ref).toBe(model.persons[1]);
```

The `expect` function can be any assertion library you like. The `Hello world` example uses Vitest.

## Handling multi-target references

With [Langium 4.0.0](https://github.com/eclipse-langium/langium/blob/main/packages/langium/CHANGELOG.md#multi-target-references) the handling of multi-target references is supported.

Multi-target references are cross-references that can point to multiple targets instead of just one. The AST representation changes from a single `Reference` to an `MultiReference` objects. The mechanism to resolve multi-target references is similar to single-target references. The scope provider still provides a scope for each cross-reference, but the linker now can link multiple targets from the scope to the multi-reference.

All you need to do to change a single-target reference to a multi-target reference is to write:

```langium
... person=[+Person:ID] ...
```

...instead of `person=[Person:ID]` in your grammar.

The resolution mechanism stays the same. But be aware of the AST structure change: every `...ast.person.ref` becomes an array of references: `...ast.person.items` where each `item` is a `Reference`-like object (it has a `ref` field again).

### When to use multi-target references?

A typical use case for multi-target references are namespaces or partial classes. The core idea is that you want to declare multiple symbols under the same scope. Typically, these declarations are split into different files. Think of C++ `std` namespace:

```cpp
//vector.hpp
namespace std {
    class vector { ... };
}

//map.hpp
namespace std {
    class map { ... };
}

//main.cpp
#include <vector>
#include <map>
std::vector<int> v;
std::map<int, int> m;
...
```

As you can see, the `std` namespace is used to group related classes together, allowing for better organization and avoiding naming conflicts. In this case, both `vector` and `map` are part of the `std` namespace, and they can be used in `main.cpp` without any issues.
The multi-target reference would be used inside of the variable declarations of `v` and `m` to point to the same `std` namespace declarations.
