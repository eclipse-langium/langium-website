---
title: "Generation in the Web"
weight: 7
draft: true
---

And this guy will be talking about how to perform generation the web. We're assuming that you've already looked over most of our other guys at this point, or are relatively comfortable with  Langham and Monaco in the web. We also send that you have already set up song from generation for your language. If you haven't, you should go back to the generation guide, and take a moment to read that over and make sure that you can only understand it, but I've also set up something that is generated so that you can then use that I'll put in this part of the guide.  in the case that you don't have a language to customize, you can use one of our pre-existing languages Like Langer mini logo, which is specially designed to run in the web and follow along with that.

One of the first things we want to establish is what we're going to be generating for in the web. This is often quite dependent on the domain of the language which you're working with. For this guy will be talking about the mini local language implement it in the Langham engineering framework. The domain for this language is dry and corresponds to graphical outfit. This works quite well and a web best contacts, as we will be using our language to correspond to drawing instructions on HTML5 canvas. For your language, you could easily perform some similar kind of matching, such as for a state machine based example with some sort of diagram based output to represent the state machine also shown on the webpage. There's no way to do this, so it's a little bit flexible based on the requirements and needs of your language and also your design application.

For mini logo our goals upfront or pretty simple. Support editing mini logo programs in the browser. Support generation of drawing instructions from these programs also in the browser. Have a simple programs running in the browser, that uses these drawing instructions To produce some sort of visualization on an HTML five canvas. For these requirements, it makes the parts that we're gonna be designing for the generator really really clear out front. This is a very important step, even though it involves no actual coding, as it will dictate the rest of your design process. Setting up the generator the web, but without a clear intention is to hot will be used, could lead to more problems than solutions down the road.

Based on the guys that we have already read so far, particular one about running Langham and Monaco in the web, we already have set up working with mini logo and Monaco pause language 2 web. If you haven't already set this up you can go back to that guide and give it a look over to understand what's going on there. Continuing off of this example presented in that guide, we want to add a new feature to arm for mentation. Do you want to pull out only the generator separate from the actual language server worker. We have to do this because the current format for the worker, is it immediately executable format, and does not support allowing some other imports from it. So, to get access to the generator self we have to produce a second bundle that specifically exports the generator endpoint. Turns out this is actually pretty easy to do.

We'll start by adding a new folder, called web. Much like the Sealife older this folder will describe or any points but in a web-based contacts. Well then create an index.TS file in this folder. This file will contain a single exported function as our entry point, which will be accessible from the bundle will be importing later on. For mini logo, this function is called parts and generate. Much like the name suggests, dysfunction takes a mini local program as a literal string, parts is it, and then generates output based on the AST that is produced. The share some logic that was used with the COI before, so the coach should be familiar. However, since you're working in the web, there is no CLI here so we're just invoking the functions directly.

We do have to make a slight change to the way that we extract an AST note however. Previously we actually use a file on disk to actually parts and perform some generation off of. In the web, we have no such file, instead it's a string stored in memory. So we're going to do is create a document in memory that has an arbitrary you are, that suggested it is in a memory document. Well then constructors document and add validation checks to it. At this point we can then check the parts result and return it as it is without any other considerations. Without the steps you would have some significant issues, as the default no distraction would not work since there is no physical file on this to work with anymore.

As a sidenote it's important to make sure that the code that your generator depends on, is not tightly coupled with any file system related functionality, or anything that is not compatible working in the browser. From the human generate example with the hello world language, the logic for the generator is deeply tied with the CLI. Thankfully the implementation is quite simple, and it's not too difficult to decouple, but it is something that you will need to do couple if you wish to have generation logic that is completely independent of any seal I logic that is fixed to the desk.

Now this files complete I can add a new script in my package Jason cold milk generator. Descriptive OTS build much like we have been doing before, except it will be targeting are newly created web/index.TS file; which is the entry point for generator alone. Will also give us a global name to make the import user to manage.

```
"build:generator": "esbuild --minify ./out/web/index.js --bundle --global-name=MiniLogo --outfile=./out/libs/minilogo-generator.js",
```

 using the examples presented in the previous guides, will be looking at the static age to my page that we used in the lingam plus Monaco guide. We can use everything we've written before, but at a script at the top of the file that imports from our libraries, or bundles mini logo generator file. Because of the way we've constructed this bundle, it will automatically make the mini logo term available at the top of the global scope. We can then add a simple button to her page, and register for click events specifically for function, let's call it update local canvas. We can implement this function below and I skip module, so that we have access to all of the other Monaco editor support. In this function, as a call back, we can retrieve the current contents of the editor that have been changed using client that editor don't get value open). After this we can directly invoke the generator using our mini logo the parts and generate function, and passing the new program value into it. At this point, the result is completely dependent on whatever our generator returns. For many logo generator returns a list of commands I can be executed by some simple stack base machine. This means we can pass or commands into a simple JavaScript function that removes elements from the stack one of the time, and performs an action that corresponds to that at that element type.

Now we need a place to actually perform are drawn, and also function to perform the drawing with. In order to do this mean to make a pair of changes to example. The first is that we need to actually add a canvas element on the page. This is a simple as adding a canvas HTML element would you give an idea, so that we can find it easily later. In my example I also wanted to be able to view Monaco in the cameras side by side so I've included a little bit of CSS here to split the views roughly 5050.

I've also included some boiler plate logic to actually take the commands that are produced by the generator, and perform drawing actions. This voice generating redundant code that would be the same on every generation. As far one clued an update many local canvas function, which gets gets the canvas context set up a basic state, and removes commands off the stack one of the time. For each command specific action is hand, which corresponds to some affect on either the canvas, the state, or both. For example, the pinup command simply changes the state so that the pennies up and that the any pre-existing stroke is completed on the campus. On the opposite, the pen down command set the states that the pen is not down, and it also begins a path on the current canvas context I said the position. The movie man provides a relative x & y position, Which are added to the pre-existing state. Listen corresponds to move in the context to that position. Lastly the color command fairly simply changes a stroke style to a given color.

As you may have noticed, the generation does not actually handle any of the control for logic, such as 44 loops. It also doesn't include any notion of macros or references, or definitions. This is because they are not actually needed to perform the actual generation logic. I could export them, through the generation, and be able to update my machine here to be able to run on these types. But for the simple example I was only interested in the direct commands that manipulate the context. Because I was aware that I only needed these commands I was able to offered most of the generator work to produce some simple outfit that would work. In your case, you may find some simplification during generation helpful, as a form of Semantically preserving translation it does not change the meaning of your program but perhaps makes it simple to work on. At one point, me logo even generated it's on JavaScript code to run all these commands, effectively performing a simple transpiration process; but without optimizations.

Lastly, a small delay is added between commands that are removed off of the stack, so sick of the effect of the campus is being drawn in real time. This is purely graphically entertaining, and has no functional relevance, but it definitely add a nice touch to the end result.

No, using the same xpress server that I wrote before, with all that static assets. I can proceed to start my application view it in the web, and see my program on the left, and an html canvas on the right. An image should be drawn in the canvas, wishing to get to the generation & stack machine is working. Addition, I can change the program Contained in Monaco, and hit the update campus button. I should see the canvas clear, and a new image be drawn with the star changes.

And that's it. At this point we have a complete language running in the web based contacts with Monica, with LSP support. We also have a generator and point that allows taking our program in Monaco, converting it to self command, and then running this through a simple stock base machine in JavaScript to produce in effect on the HTML5 campus. Although this example is purely demonstrational, indicates how lingam can be clean the integrated through all steps in the process to produce a nice functional language implementation with excellent support throughout the way. It is easy to imagine how one couldn't extend this generator or this example and produce their own functionality. For example extending from an HDMI five canvas to a three-dimensional web GL context might be it next path. It's even possible to imagine that you might have multiple generator target, as there is no requirement to simply have a single generator endpoint. You could add as many as you need for each specific target, and even share functionality between generators for a common components or aspects that are shared. This is hugely advantageous and decouples it completely from the implementation on the browser side, it's totally up to you I want it to work.

At this point now we have a full stack for a system and we aren't even using it back in. However should we choose to do so we could easily Inc. back in and he's websites to make that work with Monica.

We hope that this is been an lighten the experience reading through these guys, and that you've learned something about how to implement your language using the Langium engineering framework.