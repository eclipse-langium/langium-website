---
title: "Generation"
weight: 3
draft: true
---

That's good we'll be talking about the basics of generation using an abstract send text tree just from the Langham best language. If you haven't already, make sure to go back over and check out the customizing your seal like guides and validation and grammar guys, those are quite helpful for understanding the kinds of things will be talking about in this guy.

Assuming you have an understanding of how to extend your COI and modify it, then you'll be interested in wanting to implement custom generator functionality and beyond Something Simple is writing a file the desk. In particular for any even simplistic abstract send text to hear that your program produces, you want to be able to convert this into some generated outfit that matches your style. Throughout these guys we've been using the minilogo language as a motivated example describing how aspects of Langham Match with an actual language is being written. To keep in line with that will be describing how mini local language is generator is written so that we can actually output drawing instructions for a custom stock base machine for mini logo. Don't worry it won't be too complex it will just give you the general idea of how you can do is teach reversals to produce the kind of generator I'll put that you would need for some other application.

If you're following along using the human generator sample, Kim mind that the generator is different for the mini local example, and instead located in source/generator/generator.es. As mentioned in prior guides, this slight change in design is due to having the generator independent of the CLA. This is important for mini logo, because its primary target is actually running in the web, but it is equally capable of building using the native application form that as well.

To get your generator started you're gonna wanna begin with the corner of your abstract syntax tree this will corresponds with the entry your grammar. In the hell world example, and in the mini logo example, this will be the model outlet. This corresponds with an interface describes injure abstract syntax, or semantic model, or metal model (Whatever attorney choose to use describe the structure closing parentheses). Based on the structure of the CST, and the fact that it is in fact a tree, we can traverse it pretty easily by going through the properties on the tree, the objects in the tree or corresponds to the rules that they are instantiated from, and the properties will corresponded as assignments that we made to the rule body body some selves.

In terms of how you do this to Russell, you have a couple of choices. One of the easiest ways is to directly to verse the object by hand. This is a simple as accessing the properties and mapping functions onto those properties such that generation is define for every class of object in your ass to you. Whenever you encounter a property of type of that object, you were simply call the generator function for that object. These functions can then be constructed in such a way that they allowed calling through your tree, and producing some sort of finalize generator output. In order to support this kind of compositional reasoning, you want to have some sort of way to put together the contents, and we provide a nice composite generator note to help with this task. This gives you a little more structure with constructing or outputs, without resorting to just straight up adding strings together.

The other way you could do this, is by converting the AST it's self into a list. This could be done by doing in in order traversal of the AST,  which converts your tree structure into a flat list,. At which point you can simply pop elements off oh, or on shift, depending on which order are you going to be performing a generation, and then generate based on each element in your language. The point of keeping mine here is that you will still be requiring some functions to convert elements of your AST back into some generate output. However the way in which you can build these functions is no longer structured within the functions of cells based on the order of how the objects are, particularly with which properties which types. Instead, with this style, you would simply be able to invoke any function for any object in your AST flat from the generator top itself and you would want to stay away from the properties as they will come up anyways during the traversal call mom.

Personally, find the first approach to work quite well although it is inherently more for both and more problematic if you make more changes to your language particular structural changes that will change the ass T-shirt. For smaller language is this is us fairly manageable, like for example languages like mini logo. However, for larger languages war production languages, you might want to consider the secondary approach as a more flexible version of a generator that camper I can remain functional across relatively small send text changes. This will save your time and effort down the road so long as the generator itself remains correct.

 We're almost done the generator section here but there's one of the point I would like to talk about, that's evaluation. There may be points where you need to actually evaluate not just expressions but other constructs in your language order to produce some sort of value table to use for the generator. If your generator is producing one to one mappings from one target language to another, you may not require this evaluation, as you're simply translating the evaluation into another language not actually performing it. However in the case of mini logo we are producing output for a stack paste machine very simple one to that consumes only drawing instructions not many local code. In order to make this work we have to convey such things like the commands that we are shooting with absolute positions, which means we need to evaluate references and arithmetic expressions to their final values.

This means, that we need a semantics. Thankfully mini logo is incredibly simplistic Sara semantics is a kin to Pam Dass, for basic arithmetic evaluation. Ask for references, we only need to worry about shadowing, due to lexical scoping, or static scoping call which is the default scoping in Langham. However we won't talk about scoping more in the sky, as that is a completely separate topic and requires more time and space to focus on. So if I said to say, in our case we need an environment. Due to our simplistic structure we only have two kinds of constructs that can be brought to the top level, statements or definitions. These two definitions simply add call Abu constructs to are off marmot. However we don't need to track this tracked in Lincoln itself. Stevens however, can invoke macros which do need an environment since they are dependent on the decorations around them to know whether they work, and the values of the predators that are passed. This can be done as simple as direct lab value that is passed along  throw generation.

Once we have a way 2000 expressions to final values, we don't need to worry about translating Final commands tutor equivalent drawing instructions. Because the stack base machine will be using is very very simple we only need to give the literal conversions from each drawn command to the Quizlet. This is a trivial one to one translation and it makes our life a lot easier. As for the values that are session with these commands we can simply pass along the ones that we have just completed using our simplistic semantics.

And that's it. We now have the ability to generate some sort of output using a given input language. And this example, guide, you're able to take a mini logo code and converted into drawing instructions that can be consumed with absolute positions, why some sort of simple stock base with Shane. This open the door for us to write such a stack base machine and JavaScript or typescript, and put it on the web. As you may be able to tell we're going with this, this opens the door for us to not only run lingam in the web., But be able to actually generate in the web as well as and seamlessly have been fucked with our language. However this could also work just fine using COI that we have customers from before to produce local output code using some local application. The choice of mentation is up to you based on your constraints and limitations, but unlimited by your creativity.

And our next guide, will be talking about how you can take Langham bundle it to reduce the size. This is an important step before deployment as an extension, or even in the web.