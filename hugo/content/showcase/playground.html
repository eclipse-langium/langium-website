---
title: "Playground"
weight: 0
type: langium
layout: showcase-page
url: "/showcase/playground"
img: "/assets/Langium_Statemachine.svg"
description: Write your own language on the left and try out your own language edtor on the right.
geekdochidden: true
draft: false
noMain: true
---

<script type="module">
  import { MonacoEditorLanguageClientWrapper } from "../libs/monaco-editor-wrapper/index.js";
  import { buildWorkerDefinition } from "../libs/monaco-editor-workers/index.js";

  buildWorkerDefinition(
    "../libs/monaco-editor-workers/workers",
    new URL("", window.location.href).href,
    false
  );

  MonacoEditorLanguageClientWrapper.addMonacoStyles("monaco-editor-styles");
  MonacoEditorLanguageClientWrapper.addCodiconTtf();

  const divRoot = document.getElementById("monaco-editor-root");
  const style = "width:50%; display:inline-block; height: 100%";
  const leftEditor = document.createElement("div");
  leftEditor.setAttribute("style", style);
  const rightEditor = document.createElement("div");
  rightEditor.setAttribute("style", style);
  divRoot.appendChild(leftEditor);
  divRoot.appendChild(rightEditor);

  function setupEditor(domElement, name, syntax, content, worker, clientCallBack) {
    const client = new MonacoEditorLanguageClientWrapper(name);

    const editorConfig = client.getEditorConfig();
    editorConfig.setMainLanguageId(name);
    editorConfig.setMonarchTokensProvider(syntax);

    editorConfig.setMainCode(content);
    editorConfig.theme = "vs-dark";

    editorConfig.useLanguageClient = true;
    editorConfig.useWebSocket = false;

    const workerURL = new URL(worker, import.meta.url);

    const lsWorker = new Worker(workerURL.href, {
      type: "classic",
      name: "LS",
    });
    client.setWorker(lsWorker);

    clientCallBack(client);

    client.startEditor(domElement);
    window.addEventListener("resize", () => client.updateLayout());
  }

  //setup left Langium editor and right user editor
  setupEditor(
    leftEditor,
    "langium",
    {
      keywords: [
        "bigint",
        "boolean",
        "current",
        "Date",
        "entry",
        "extends",
        "false",
        "fragment",
        "grammar",
        "hidden",
        "import",
        "infer",
        "infers",
        "interface",
        "number",
        "returns",
        "string",
        "terminal",
        "true",
        "type",
        "with",
      ],
      operators: [
        "->",
        ",",
        ";",
        ":",
        "!",
        "?",
        "?=",
        ".",
        "..",
        "@",
        "*",
        "&",
        "+",
        "+=",
        "<",
        "=",
        "=>",
        ">",
        "|",
      ],
      symbols:
        /->|,|;|:|!|\?|\?=|\.|\.\.|\(|\)|\[|\[\]|\]|\{|\}|@|\*|&|\+|\+=|<|=|=>|>|\|/,

      tokenizer: {
        initial: [
          {
            regex:
              /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\//,
            action: { token: "string" },
          },
          {
            regex: /\^?[_a-zA-Z][\w_]*/,
            action: {
              cases: {
                "@keywords": { token: "keyword" },
                "@default": { token: "ID" },
              },
            },
          },
          { regex: /"[^"]*"|'[^']*'/, action: { token: "string" } },
          { include: "@whitespace" },
          {
            regex: /@symbols/,
            action: {
              cases: {
                "@operators": { token: "operator" },
                "@default": { token: "" },
              },
            },
          },
        ],
        whitespace: [
          { regex: /\s+/, action: { token: "white" } },
          { regex: /\/\*/, action: { token: "comment", next: "@comment" } },
          { regex: /\/\/[^\n\r]*/, action: { token: "comment" } },
        ],
        comment: [
          { regex: /[^\/\*]+/, action: { token: "comment" } },
          { regex: /\*\//, action: { token: "comment", next: "@pop" } },
          { regex: /[\/\*]/, action: { token: "comment" } },
        ],
      },
    },
    `grammar Statemachine

entry Statemachine:
    'statemachine' name=ID
    ('events' events+=Event+)?
    ('commands'    commands+=Command+)?
    'initialState' init=[State]
    states+=State*;

Event:
    name=ID;

Command:
    name=ID;

State:
    'state' name=ID
        ('actions' '{' actions+=[Command]+ '}')?
        transitions+=Transition*
    'end';

Transition:
    event=[Event] '=>' state=[State];

hidden terminal WS: /\s+/;
terminal ID: /[_a-zA-Z][\w_]*/;
terminal INT returns number: /[0-9]+/;
terminal STRING: /"[^"]*"|'[^']*'/;

hidden terminal ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//;
hidden terminal SL_COMMENT: /\\/\\/[^\\n\\r]*/;
`,
    "../libs/worker/langiumServerWorker.js",
    (client) => {}
  );
</script>
